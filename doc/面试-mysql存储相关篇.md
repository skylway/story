### mysql存储相关篇


```
数据库篇
```
```
1 mysql优化方式：

	 a.表设计合理，一张表字段不能太多
	 b.表必须有主键，例如自增主键
	 c.选取最适用的字段属性
	 d.使用InnoDB存储引擎, 解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高
	 f.必须使用UTF8字符集 万国码，无需转码，无乱码风险，节省空间
	 e.数据表、数据字段必须加入中文注释  N年后谁tm知道这个r1,r2,r3字段是干嘛的
	 g.禁止使用存储过程、视图、触发器、Event 高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧
	 h.禁止存储大文件或者大照片 为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好
	 i.禁止使用外键，如果有外键完整性约束，需要应用程序控制  外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先
```
```
2 如何分库分表:

	 a.mycat cobar自动分库分表 数据库中间件
	 b.水平切分，选取某个列或几个列的值进行hash运算，然后根据hash的结果分散到不同的数据库表中,例如会员表放到10*10库表里面，使用UUID取余（%）10 将数据存在不同库表里面。
	 c.按时间分区表（partition)
	 d.并发数据量大，做搜索时候可以把数据LOAD ES，去做搜索。
```
```
3 mysql引擎类型有哪些 InnoDB与MyIsam区别

	 有 MyIsam , 2. InnoDB, 3. Memory, 4. Blackhole, 5. CSV, 6. Performance_Schema, 7. Archive, 8. Federated , 9 Mrg_Myisam

	 a.MyISAM：成熟、稳定、易于管理，快速读取。不支持事务，表级锁。MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不支持事务的设计。不支持外键的表设计。查询速度很快，如果数据库insert和update的操作比较多的话比较适用。MyISAM极度强调快速读取操作。MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

	 b.InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引(5.6.4以后版本开始支持FULLTEXT类型的索引)。等。InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。经常更新的表，适合处理多重并发的更新请求。支持事务。可以从灾难中恢复（通过bin-log日志等）。外键约束。只有他支持外键。支持自动增加列属性auto_increment。MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

		 myisam:
		.frm: 存储表定义
		.myd(MYData):存储数据
		.MYI(MYindex):存储引擎

		innodb:
		.frm:存储表定义
		.idb:存储数据和索引,在同一个文件中
```
```
4 mysql索引结构算法 什么是B+Treee索引结构。快在哪儿？还有记得最佳左前缀法则

	 a.索引是帮助MySQL高效获取数据的数据结构,提高数据查询的效率，默认索引结构B-Tree
	 b.​B-Tree是能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。
	 c.B+Tree 是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。B+TREE 关键字的搜索采用的是左闭合区间，之所以采用左闭合区间是因为他要最好的去支持自增id，这也是mysql的设计初衷。即，如果id = 1命中，会继续往下查找，直到找到叶子节点中的1。

	 d.B+TREE 关键字的搜索采用的是左闭合区间，之所以采用左闭合区间是因为他要最好的去支持自增id，这也是mysql的设计初衷。即，如果id = 1命中，会继续往下查找，直到找到叶子节点中的1。
	 e.B+TREE 根节点和支节点没有数据区，关键字对应的数据只保存在叶子节点中。即只有叶子节点中的关键字数据区才会保存真正的数据内容或者是内容的地址。而在B树种，如果根节点命中，则会直接返回数据。并且在B+TREE中，叶子节点不会去保存子节点的引用。
	 f.B+TREE叶子节点是顺序排列的，并且相邻的节点具有顺序引用的关系，如上图中叶子节点之间有指针相连接。

	 请思考和回忆myisam与innodb B+ Tree区别？
```
```
4 MySQL主从同步，和主主同步有哪些区别，以及优劣势？
	a.主主同步与主从相互相互结合，分布式架构，解决单点写的问题。实现写操作的高可用。故障转移。
	b.主从复制:主要目的是实现数据库读写分离，写操作访问主数据库，读操作访问从数据库，从而使数据库具有更强大的访问负载能力，支撑更多的用户访问。复制原理是：当应用程序客户端发送一条更新命令到数据库的时候，数据库会把这条更新命令同步记录到Binlog中，然后由另外一个线程从Binlog中读取这条日志，然后通过远程通讯的方式将它复制到从服务器上面去，从服务器获得这条更新日志后，将其加入到自己的Relay log中，然后由另外一个SQL执行线程从Relay log中读取这条新的日志，并把它在本地的数据库中重新执行一遍。
	c.主主复制原理:当客户端程序对主服务器A进行数据更新操作的时候，主服务器A会把更新操作写入到Binlog日志中。然后Binlog会将数据日志同步到主服务器B，写入到主服务器的Relay log中，然后执Relay log，获得Relay log中的更新日志，执行SQL操作写入到数据库服务器B的本地数据库中。B服务器上的更新也同样通过Binlog复制到了服务器A的Relay log中，然后通过Relay log将数据更新到服务器A中。通过这种方式，服务器A或者B任何一台服务器收到了数据的写的操作都会同步更新到另一台服务器，实现了数据库主主复制。主主复制可以提高系统的写可用，实现写操作的高可用。
```
```
4.1 MySql主从复制中同步模式、异步模式、半同步模式？
  a.异步复制：当主库有更新的时候，主库会把更新操作的SQL写入二进制日志(Bin log)，并维护一个二进制日志文件的索引，以便于日志文件轮回（Rotate）。在从库启动异步复制的时候，从库会开启两个I/O线程，其中一个线程连接主库，要求主库把二进制日志的变化部分传给从库，并把传回的日志写入本地磁盘。另一个线程则负责读取本地写入的二进制日志，并在本地执行，以反映出这种变化。较老的版本在复制的时候只启用一个I/O线程，实现这两部分的功能。
MySQL本身支持单向的、异步的复制。异步复制意味着在把数据从一台机器拷贝到另一台机器时有一个延时 – 最重要的是这意味着当应用系统的事务提交已经确认时数据并不能在同一时刻拷贝/应用到从机。通常这个延时是由网络带宽、资源可用性和系统负载决定的。然而，使用正确的组件并且调优，复制能做到接近瞬时完成。(通常没说明指的都是异步，即主库执行完Commit后，在主库写入Binlog日志后即可成功返回客户端，无需等等Binlog日志传送给从库，一旦主库宕机，有可能会丢失日志。)
b.同步复制可以定义为数据在同一时刻被提交到一台或多台机器，通常这是通过众所周知的“两阶段提交”做到的。虽然这确实给你在多系统中保持一致性，但也由于增加了额外的消息交换而造成性能下降。
使用MyISAM或者InnoDB存储引擎的MySQL本身并不支持同步复制，然而有些技术，例如分布式复制块设备（简称DRBD），可以在下层的文件系统提供同步复制，允许第二个MySQL服务器在主服务器丢失的情况下接管（使用第二服务器的复本）。
c.半同步复制 MYSQL 5.5开始，支持半自动复制。之前版本的MySQL Replication都是异步（asynchronous）的，主库在执行完一些事务后，是不会管备库的进度的。如果备库不幸落后，而更不幸的是主库此时又出现Crash（例如宕机），这时备库中的数据就是不完整的。简而言之，在主库发生故障的时候，我们无法使用备库来继续提供数据一致的服务了(而半同步复制，是等待其中一个从库也接收到Binlog事务并成功写入Relay Log之后，才返回Commit操作成功给客户端；如此半同步就保证了事务成功提交后至少有两份日志记录，一份在主库Binlog上，另一份在从库的Relay Log上，从而进一步保证数据完整性；半同步复制很大程度取决于主从网络RTT（往返时延），以插件 semisync_master/semisync_slave 形式存在。 )
```
```
5 MySQL防止注入有哪些方式？
	addslashes，不要相信输入，做好字段过滤和校验
	mysql_real_escape_string() 
	使用prepared statements（预处理语句）和参数化的查询，可以有效的防止sql注入 PDO
	在php.ini中开启magic_quotes_gpc on,对输入进行转义
```
```
6 描述MySQL的注入原理？
	黑客输入2 or 1=1 则sql为select * from test where id=2 or 1=1;这样就会输出test中所有的数据，就完成了一次sql注入
	黑客输入用户名ceshi' or 1=1 --和密码123456 则sql为select * from test where username='ceshi' or 1=1 -- ' and password='e10adc3949ba59abbe56e057f20f883e'这样查询的时候就相当于执行的sql为select * from test where username='ceshi' or 1=1，因为'--'注释了后面的sql 这样又完成sql注入
```

```
7 哪些情况下字段允许null，哪些情况下不允许？
	null的话 not in  != count 等等都有点小问题，
	不建议使用null
	所以说索引字段最好不要为NULL，因为NULL会使索引、索引统计和值更加复杂，并且需要额外一个字节的存储空间
```
```
8 MySql中的事务嵌套
  Mysql是不支持嵌套事务的，开启了一个事务的情况下，再开启一个事务，会隐式的提交上一个事务。
```

```
9 Elasticsearch 如何实现类似SQL的 WHERE id = 12 AND gender IN ('male', 'unknow');

```
```

10 Elasticsearch 如何实现类似SQL的 GROUP BY nickname

```

```
11 Redis 在事务中如何做到：发现事务执行过程中数据被污染就执行失败？
	multi exec discard
	WATCH KEY 乐观锁(check-and-set) WATCH 命令为事务提供一个check-and-set (CAS) 行为
	当 EXEC 被调用后, 所有的keys都将UNWATCH，不管这个事务会不会终止。同样，当一个客户端链接关闭后, 一切都将UNWATCH
```
```
12 Redis 有几种数据类型

string list hash 集合set等  setnx锁
```
```
13 Redis Hash原理 Hash一致性
```
```
14 Redis有持久化机制，为啥不能做专门的持久化数据库存储？

	Redis 的持久化有 rdb 和 append only file
	RDB 定时(一般比较长..)刷到磁盘, 丢数据的风险比较大. 当然有些应用是可以忍受这种级别的丢数据的. RDB 加载很快.
	Append only file 貌似每秒 fsync 一次, 没看过具体的代码, 不知道开启了对请求处理速度有没有影响. 这个也会丢数据, recover 速度比较慢. 不过大部分情况下开启 aof 就够用了. 除非有 sql 查询的需求. 
	以前我设计开发过一个 key-value DB, 丢数据 /性能权衡的问题非常麻烦...
	redis 的持久化是异步的，出现异常丢数据的概率很高。
	mysql 可以做复杂的查询。

	a.场景不一样， redis 的持久化是附加功能， mysql 的持久化是核心功能
    b.redis 的 flushdb 、 flushall 太犀利了，用 redis 来持久化数据总感觉不靠谱
	c.持久化机制不一样，举个例子来说，当数据量达到 10G 的时候，你改了几条数据， mysql 只增量地持久化这几条数据；而 redis 只知道自己该持久化了，然后把 10G 数据完整地从内存 dump 到磁盘，是不是很过瘾
	d.MySQL 有权限控制，用户可以精确到每个 IP 的每个账户，目标可以精确到每个表的每个操作。
```

```
15 mysql本身锁机制怎样
读锁？
写锁？
A,Myisam的锁比较容易理解，无论是读还是写都只会加表锁，表锁又分为read锁和write锁
B,Myisam的read、write表锁其实可以看做一种元数据锁，这种锁对其他存储引擎例如innodb表也可以加
C,由于Myisam这样的锁机制，导致Myisam是一款读性能较好，并发写性能较差的存储引擎，本文主要讨论如今的MySQL默认存储引擎InnoDB的锁机制
D,InnoDB也可以使用lock tables ... read/write来添加元数据表锁
E,InnoDB支持的事务表锁有：
    a, S ：即lock tables ... read添加的S锁。
    b, X ：即lock tables ... write添加的X锁。
    c, IS：表级意向共享锁，即表示事务有向底层资源加共享行锁的意向。如select ... lock in share mode语句，在加行锁之前会在表上现加IS锁，这样可以提高锁冲突检测的效率，同时也可以避免事务在表级添加会使其他事务行锁失效的表级锁。
    d, IX：表级意向独占锁，即表示事务有向底层资源加独占行锁的意向。一般来说delete、update语句和select ... for update语句都会在加行锁之前先加表级IX锁，除非未用到索引（此时直接加表级X锁）。

E,InnoDB行锁有以下四种:
    a, Record lock 即在索引上加的锁，lock_mode分为S和X两种模式
    b, Gap lock    即间隙锁，锁定不存在的索引记录，官方定义是：Gap lock用于锁定2个索引记录之间、或第一个索引记录之前、或最后一个索引记录之后的范围
    c, Next-key lock 即Record lock和Gap lock的合体
    d, 插入意向锁（Insert Intention Locks）
    f, Innodb内存锁
```

```
MySQL事务隔离级别?
提到事务隔离级别就必须先明确以下三种读：
    脏读：读到了其他事务已修改但未提交的数据
    不可重复读：由于其他事务的修改，导致同一事务中两次查询读到的数据不同
    幻读：由于其他事务的修改，导致同一事务中两次查询读到的记录数不同
A.READ UNCOMMITTED  这种隔离级别下普通select语句是不加事务锁的，因此会产生脏读，这种事务隔离级别是应当完全避免的。除select语句以外的其他语句加锁模式与READ COMMITTED一样。
B,READ COMMITTED  同REPEATABLE READ一样，这种隔离级别下也实现了一致性非锁定读，但区别在于此隔离级别下的一致性读是语句级的，即只能避免脏读，不能避免不可重复读和幻读。其实现方式大致是：
    a, 一致性非锁定读的select语句检测要锁定的索引记录上是否有独占锁（在server层也会添加S模式的record lock，此锁为server层的元数据库锁，非innodb事务锁）
    b, 如果有独占锁那么到undo中寻找最近的前镜像
    c, 如果没有独占锁那么直接读取数据
C,REPEATABLE READ 这是MySQL的默认事务隔离级别。在一个事务当中第一次读会建立一个全库snapshot，同事务下的select语句会读取这个snapshot来实现一致性非锁定读。而第一个snapshot的建立猜测与READ COMMITTED下的读取机制一样。同事务的select语句会读取这个snapshot的数据来实现一致性非锁定读，这个snapshot是针对整个数据库中所有支持MVCC机制的表的，即在snapshot建立后读取任意其他表都只会读取到snapshot中的快照数据
D, SERIALIZABLE 这种事务隔离级下select语句即便不加lock in share mode也使用lock_mode=S的行锁，select自成事务，锁直到事务结束才释放。这种隔离级别下可以避免脏读、不可重复读和幻读。

```

```
16 组合索引 最左前缀用法查询? like 'xxxxx%' '%xxxx%' 
student_age 和 student_addr 设置完联合索引
where student_age = 10 and student_addr = '北京’  使用了索引
where student_addr = ‘北京’ and student_age = 10  使用了索引
where student_age = 10  使用了索引
where student_age like ‘10%’ 使用了索引
where student_age like ‘%10%’ 没使用索引
where student_addr = '北京’  没使用索引 睁大眼睛，这就是最左匹配原则。

A,MySQL 建立联合索引的规则是这样的，它会首先根据联合索引中最左边的、也就是第一个字段进行排序，在第一个字段排序的基础上，再对联合索引中后面的第二个字段进行排序，依此类推。
B,综上，第一个字段是绝对有序的，从第二个字段开始是无序的，这就解释了为什么直接使用第二字段进行条件判断用不到索引了（从第二个字段开始，无序，无法走 B+ Tree 索引）！这也是 MySQL 在联合索引中强调最左前缀匹配原则的原因

```

```
17,mysql 事物 ACID？？ 
ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求
```